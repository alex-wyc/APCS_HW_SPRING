\documentclass [12 pt, twoside] {article}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{setspace}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codeblue}{rgb}{0,0,0.6}
\definecolor{backcolor}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor = \color{backcolor},
	commentstyle = \color{codeblue},
	keywordstyle = \color{codegreen},
	numberstyle = \color{codegray},
	stringstyle = \color{magenta},
	basicstyle = \footnotesize,
	breakatwhitespace = false,
	breaklines = true,
	captionpos = b,
	keepspaces = true,
	numbers = left,
	numbersep = 5pt,
	showspaces = false,
	showstringspaces = false,
	showtabs = false,
	tabsize = 4
}

\lstset{style = mystyle}

\begin{document}

\title{APCS Notes}
\author{Yicheng Wang}
\date{2014-2015}

\maketitle
\newpage
\setcounter{tocdepth}{3}
\tableofcontents
\newpage

\section{2015-02-05}
\subsection{Do Now}
Figure out what the following code does.

\begin{lstlisting} [language=Java]
public void printme(int n) {
	if (N > 0) {
		printme(n - 1);
		System.out.println(n);
	}
}
\end{lstlisting}

It should print out an increasing sequence of numbers
from 1-N.

\subsection{Stack and ROP}
The stack on top is the current function, and each layer beneath that
is the function that called the current function.

\subsection{Recursion}



Simple recursive problem: FACTORIAL


Hallmarks of a recursive solutioin:
\begin{itemize}
	\item Base Case: thing that stops the program, simple case you know the answer of. In the case of factorials, factorial(0) = 1
	\item Reduction Case: You need to alternate the variable in some sort of way, for example, we should do n * factorial(n - 1)
	\item Recursion: function A need to eventually call A
\end{itemize}


Final code:
\begin{lstlisting}[language=Java]
public int factorial(n) {
	if (n == 0) {
		return 1; // Base Case
	}
	else {
		return n * factorial(n - 1); // Reduction Step
	}
}
\end{lstlisting}

\section{2015-02-06}

\subsection{Traditional Recursion Examples}
\subsubsection{Fibonacci Numbers}
1, 1, 2, 3, 5, 8, 13 ...


Base Case: if n < 2, return 1


Reduction Step: fib(n) = fib(n - 1) + fib(n - 2)


Example Code:
\begin{lstlisting}[style=Java]
public int fib(int n) {
	if (n < 2) {
		return 1;
	}

	else {
		return fib(n - 1) + fib(n - 2);
	}
}
\end{lstlisting}

\subsubsection{List/String Manipulation}


Example, finding the length of a substring.


Base case: "" has length of 0


Reduction Step: 1 + "cdr" of the string, i.e. s.substring(1);


Example Code:
\begin{lstlisting}[style=Java]
public int lenStr(String s) {
	if (s.equals("")) {
		return 0;
	}
	else {
		return 1 + lenStr(s.substring(1));
	}
}


\section{2015-02-09}
\subsection{Getting out of a Maze}
\begin{enumerate}
	\item Maze vs. Laybrith: Laybrith may not have choices, mazes have choices.
	\item Strategies in solving the maze:
		\begin{itemize}
			\item Doesn't work due to loops
		\end{itemize}
	\item Greek Way of Solving Mazes:
		\begin{itemize}
			\item Invented by Odysseus, bring a thread, use process of elimination to loop through all possible intersection.
			\item Works really well.
		\end{itemize}
\end{enumerate}


Maze solving in java
\begin{enumerate}
	\item This is clearly a recursive solution.
	\item Using a recursive solution we can easily trace back the stack to find the previous intersection
	\item We represent our map as a char array of paths ('#')
	\item Base case: location is a wall OR location of exit
	\item Reduction step: call solve at a different (x,y) location, if it's a dead end, it'll be peeled off the stack due to the "return"
	\item We will try to solve the maze systematically, x+/-1, y+/-1.
\end{enumerate}
\end{document}
